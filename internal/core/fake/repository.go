// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"fethcher/internal/core"
	"fethcher/internal/repository"
	"sync"
)

type Repository struct {
	GetTransactionsByHashStub        func(context.Context, []string) ([]repository.Transaction, error)
	getTransactionsByHashMutex       sync.RWMutex
	getTransactionsByHashArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	getTransactionsByHashReturns struct {
		result1 []repository.Transaction
		result2 error
	}
	getTransactionsByHashReturnsOnCall map[int]struct {
		result1 []repository.Transaction
		result2 error
	}
	GetUserFromDBStub        func(context.Context, string, string) (repository.User, error)
	getUserFromDBMutex       sync.RWMutex
	getUserFromDBArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	getUserFromDBReturns struct {
		result1 repository.User
		result2 error
	}
	getUserFromDBReturnsOnCall map[int]struct {
		result1 repository.User
		result2 error
	}
	GetUserHistoryStub        func(context.Context, string) ([]string, error)
	getUserHistoryMutex       sync.RWMutex
	getUserHistoryArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getUserHistoryReturns struct {
		result1 []string
		result2 error
	}
	getUserHistoryReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	SaveTransactionsStub        func(context.Context, []repository.Transaction) error
	saveTransactionsMutex       sync.RWMutex
	saveTransactionsArgsForCall []struct {
		arg1 context.Context
		arg2 []repository.Transaction
	}
	saveTransactionsReturns struct {
		result1 error
	}
	saveTransactionsReturnsOnCall map[int]struct {
		result1 error
	}
	SaveUserHistoryStub        func(context.Context, string, []string) error
	saveUserHistoryMutex       sync.RWMutex
	saveUserHistoryArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	saveUserHistoryReturns struct {
		result1 error
	}
	saveUserHistoryReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Repository) GetTransactionsByHash(arg1 context.Context, arg2 []string) ([]repository.Transaction, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.getTransactionsByHashMutex.Lock()
	ret, specificReturn := fake.getTransactionsByHashReturnsOnCall[len(fake.getTransactionsByHashArgsForCall)]
	fake.getTransactionsByHashArgsForCall = append(fake.getTransactionsByHashArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.GetTransactionsByHashStub
	fakeReturns := fake.getTransactionsByHashReturns
	fake.recordInvocation("GetTransactionsByHash", []interface{}{arg1, arg2Copy})
	fake.getTransactionsByHashMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Repository) GetTransactionsByHashCallCount() int {
	fake.getTransactionsByHashMutex.RLock()
	defer fake.getTransactionsByHashMutex.RUnlock()
	return len(fake.getTransactionsByHashArgsForCall)
}

func (fake *Repository) GetTransactionsByHashCalls(stub func(context.Context, []string) ([]repository.Transaction, error)) {
	fake.getTransactionsByHashMutex.Lock()
	defer fake.getTransactionsByHashMutex.Unlock()
	fake.GetTransactionsByHashStub = stub
}

func (fake *Repository) GetTransactionsByHashArgsForCall(i int) (context.Context, []string) {
	fake.getTransactionsByHashMutex.RLock()
	defer fake.getTransactionsByHashMutex.RUnlock()
	argsForCall := fake.getTransactionsByHashArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Repository) GetTransactionsByHashReturns(result1 []repository.Transaction, result2 error) {
	fake.getTransactionsByHashMutex.Lock()
	defer fake.getTransactionsByHashMutex.Unlock()
	fake.GetTransactionsByHashStub = nil
	fake.getTransactionsByHashReturns = struct {
		result1 []repository.Transaction
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetTransactionsByHashReturnsOnCall(i int, result1 []repository.Transaction, result2 error) {
	fake.getTransactionsByHashMutex.Lock()
	defer fake.getTransactionsByHashMutex.Unlock()
	fake.GetTransactionsByHashStub = nil
	if fake.getTransactionsByHashReturnsOnCall == nil {
		fake.getTransactionsByHashReturnsOnCall = make(map[int]struct {
			result1 []repository.Transaction
			result2 error
		})
	}
	fake.getTransactionsByHashReturnsOnCall[i] = struct {
		result1 []repository.Transaction
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetUserFromDB(arg1 context.Context, arg2 string, arg3 string) (repository.User, error) {
	fake.getUserFromDBMutex.Lock()
	ret, specificReturn := fake.getUserFromDBReturnsOnCall[len(fake.getUserFromDBArgsForCall)]
	fake.getUserFromDBArgsForCall = append(fake.getUserFromDBArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetUserFromDBStub
	fakeReturns := fake.getUserFromDBReturns
	fake.recordInvocation("GetUserFromDB", []interface{}{arg1, arg2, arg3})
	fake.getUserFromDBMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Repository) GetUserFromDBCallCount() int {
	fake.getUserFromDBMutex.RLock()
	defer fake.getUserFromDBMutex.RUnlock()
	return len(fake.getUserFromDBArgsForCall)
}

func (fake *Repository) GetUserFromDBCalls(stub func(context.Context, string, string) (repository.User, error)) {
	fake.getUserFromDBMutex.Lock()
	defer fake.getUserFromDBMutex.Unlock()
	fake.GetUserFromDBStub = stub
}

func (fake *Repository) GetUserFromDBArgsForCall(i int) (context.Context, string, string) {
	fake.getUserFromDBMutex.RLock()
	defer fake.getUserFromDBMutex.RUnlock()
	argsForCall := fake.getUserFromDBArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Repository) GetUserFromDBReturns(result1 repository.User, result2 error) {
	fake.getUserFromDBMutex.Lock()
	defer fake.getUserFromDBMutex.Unlock()
	fake.GetUserFromDBStub = nil
	fake.getUserFromDBReturns = struct {
		result1 repository.User
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetUserFromDBReturnsOnCall(i int, result1 repository.User, result2 error) {
	fake.getUserFromDBMutex.Lock()
	defer fake.getUserFromDBMutex.Unlock()
	fake.GetUserFromDBStub = nil
	if fake.getUserFromDBReturnsOnCall == nil {
		fake.getUserFromDBReturnsOnCall = make(map[int]struct {
			result1 repository.User
			result2 error
		})
	}
	fake.getUserFromDBReturnsOnCall[i] = struct {
		result1 repository.User
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetUserHistory(arg1 context.Context, arg2 string) ([]string, error) {
	fake.getUserHistoryMutex.Lock()
	ret, specificReturn := fake.getUserHistoryReturnsOnCall[len(fake.getUserHistoryArgsForCall)]
	fake.getUserHistoryArgsForCall = append(fake.getUserHistoryArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetUserHistoryStub
	fakeReturns := fake.getUserHistoryReturns
	fake.recordInvocation("GetUserHistory", []interface{}{arg1, arg2})
	fake.getUserHistoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Repository) GetUserHistoryCallCount() int {
	fake.getUserHistoryMutex.RLock()
	defer fake.getUserHistoryMutex.RUnlock()
	return len(fake.getUserHistoryArgsForCall)
}

func (fake *Repository) GetUserHistoryCalls(stub func(context.Context, string) ([]string, error)) {
	fake.getUserHistoryMutex.Lock()
	defer fake.getUserHistoryMutex.Unlock()
	fake.GetUserHistoryStub = stub
}

func (fake *Repository) GetUserHistoryArgsForCall(i int) (context.Context, string) {
	fake.getUserHistoryMutex.RLock()
	defer fake.getUserHistoryMutex.RUnlock()
	argsForCall := fake.getUserHistoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Repository) GetUserHistoryReturns(result1 []string, result2 error) {
	fake.getUserHistoryMutex.Lock()
	defer fake.getUserHistoryMutex.Unlock()
	fake.GetUserHistoryStub = nil
	fake.getUserHistoryReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *Repository) GetUserHistoryReturnsOnCall(i int, result1 []string, result2 error) {
	fake.getUserHistoryMutex.Lock()
	defer fake.getUserHistoryMutex.Unlock()
	fake.GetUserHistoryStub = nil
	if fake.getUserHistoryReturnsOnCall == nil {
		fake.getUserHistoryReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getUserHistoryReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *Repository) SaveTransactions(arg1 context.Context, arg2 []repository.Transaction) error {
	var arg2Copy []repository.Transaction
	if arg2 != nil {
		arg2Copy = make([]repository.Transaction, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.saveTransactionsMutex.Lock()
	ret, specificReturn := fake.saveTransactionsReturnsOnCall[len(fake.saveTransactionsArgsForCall)]
	fake.saveTransactionsArgsForCall = append(fake.saveTransactionsArgsForCall, struct {
		arg1 context.Context
		arg2 []repository.Transaction
	}{arg1, arg2Copy})
	stub := fake.SaveTransactionsStub
	fakeReturns := fake.saveTransactionsReturns
	fake.recordInvocation("SaveTransactions", []interface{}{arg1, arg2Copy})
	fake.saveTransactionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Repository) SaveTransactionsCallCount() int {
	fake.saveTransactionsMutex.RLock()
	defer fake.saveTransactionsMutex.RUnlock()
	return len(fake.saveTransactionsArgsForCall)
}

func (fake *Repository) SaveTransactionsCalls(stub func(context.Context, []repository.Transaction) error) {
	fake.saveTransactionsMutex.Lock()
	defer fake.saveTransactionsMutex.Unlock()
	fake.SaveTransactionsStub = stub
}

func (fake *Repository) SaveTransactionsArgsForCall(i int) (context.Context, []repository.Transaction) {
	fake.saveTransactionsMutex.RLock()
	defer fake.saveTransactionsMutex.RUnlock()
	argsForCall := fake.saveTransactionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Repository) SaveTransactionsReturns(result1 error) {
	fake.saveTransactionsMutex.Lock()
	defer fake.saveTransactionsMutex.Unlock()
	fake.SaveTransactionsStub = nil
	fake.saveTransactionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *Repository) SaveTransactionsReturnsOnCall(i int, result1 error) {
	fake.saveTransactionsMutex.Lock()
	defer fake.saveTransactionsMutex.Unlock()
	fake.SaveTransactionsStub = nil
	if fake.saveTransactionsReturnsOnCall == nil {
		fake.saveTransactionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveTransactionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Repository) SaveUserHistory(arg1 context.Context, arg2 string, arg3 []string) error {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.saveUserHistoryMutex.Lock()
	ret, specificReturn := fake.saveUserHistoryReturnsOnCall[len(fake.saveUserHistoryArgsForCall)]
	fake.saveUserHistoryArgsForCall = append(fake.saveUserHistoryArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3Copy})
	stub := fake.SaveUserHistoryStub
	fakeReturns := fake.saveUserHistoryReturns
	fake.recordInvocation("SaveUserHistory", []interface{}{arg1, arg2, arg3Copy})
	fake.saveUserHistoryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Repository) SaveUserHistoryCallCount() int {
	fake.saveUserHistoryMutex.RLock()
	defer fake.saveUserHistoryMutex.RUnlock()
	return len(fake.saveUserHistoryArgsForCall)
}

func (fake *Repository) SaveUserHistoryCalls(stub func(context.Context, string, []string) error) {
	fake.saveUserHistoryMutex.Lock()
	defer fake.saveUserHistoryMutex.Unlock()
	fake.SaveUserHistoryStub = stub
}

func (fake *Repository) SaveUserHistoryArgsForCall(i int) (context.Context, string, []string) {
	fake.saveUserHistoryMutex.RLock()
	defer fake.saveUserHistoryMutex.RUnlock()
	argsForCall := fake.saveUserHistoryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Repository) SaveUserHistoryReturns(result1 error) {
	fake.saveUserHistoryMutex.Lock()
	defer fake.saveUserHistoryMutex.Unlock()
	fake.SaveUserHistoryStub = nil
	fake.saveUserHistoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *Repository) SaveUserHistoryReturnsOnCall(i int, result1 error) {
	fake.saveUserHistoryMutex.Lock()
	defer fake.saveUserHistoryMutex.Unlock()
	fake.SaveUserHistoryStub = nil
	if fake.saveUserHistoryReturnsOnCall == nil {
		fake.saveUserHistoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveUserHistoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Repository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getTransactionsByHashMutex.RLock()
	defer fake.getTransactionsByHashMutex.RUnlock()
	fake.getUserFromDBMutex.RLock()
	defer fake.getUserFromDBMutex.RUnlock()
	fake.getUserHistoryMutex.RLock()
	defer fake.getUserHistoryMutex.RUnlock()
	fake.saveTransactionsMutex.RLock()
	defer fake.saveTransactionsMutex.RUnlock()
	fake.saveUserHistoryMutex.RLock()
	defer fake.saveUserHistoryMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Repository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ core.Repository = new(Repository)
